EDIF to UCF converter
bunnie "at" bunniestudios daht com  // BSD licensed

This program takes in an EDIF netlist and creates a Xilinx-compatible 
user-constrains file (UCF). It relies upon pyparsing, tested with
version 1.5.6. You can get pyparsing at:

http://sourceforge.net/projects/pyparsing/files/pyparsing/pyparsing-1.5.6/

We use pyparsing to do the s-expression grammar processing for EDIF. 

The EDIF netlist format was tested with that produced by Altium DXP. It's
unknown whether the program works with EDIF netlists generated by other
PCB design tools. 

The program parses the EDIF netlist, and then searches for all pins 
corresponding to the specified desginator for the FPGA. It will also
apply IO standard remappings. Note that parsing a large netlist
can take a while, for a 1.8MB EDIF netlist it takes about 20-30 seconds
on 2 GHz or so laptop. Not sure why it's so slow, but I suspect it has
to do with my grammar definition. It could use some optimization.

The IO standard remappings are contained in a helper file, 
iostandard.py. Below is a sample of how to specify your IO standard
mappings. You will need to know how to write regex for Python. 

''' iostandardMaps is a list of tuples
    the first item in the tuple is a regex that is applied to the net name
    the second item in the tuple is the corresponding I/O standard

    Note that the programming aborts searching once the first match is found.
    Therefore, the last item should always be ".*" as the default match.
'''

iostandardMaps = [ ("^F_.*DQS_[NP]$", 'DIFF_SSTL18_II'),     # matches nets starting with F_ and ending with DQS_N or DQS_P
                   ("F_.*CLK_[NP]$", 'DIFF_SSTL18_II'),      # matches nets starting with F_ and ending with CLK_N or CLK_P
                   ("^F_", 'SSTL18_II'),                     # matches all nets starting with F_
                   ("_[NP]$", 'TMDS_33'),                    # matches all remaining nets with _N or _P at the end. See below.
                   (".*", 'LVCMOS33') ]                      # this is a "default" mapping, everything else gets this

# Note that the mappings are processed in order of specification. So the upper rules has precedence over the lower 
# rules. This means that the "_[NP] mapping at the bottom is overriden by the "F_ ... CLK_[NP]" mapping at the top.
# If your schematic assigns net names with prefixes unique to each subsystem, you can use this feature to split
# out the IO standard for each subsystem while having a default mapping to catch-all others
#
# If you do not want to use any IO standard remappings, just specify an empty list, i.e. comment out the above, and
# uncomment this one line:
#
# iostandardMaps = []
